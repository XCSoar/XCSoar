---
alwaysApply: true
---

# XCSoar Project Rules

## Code Style

### Formatting
- 79 columns maximum (reasonable exceptions allowed)
- Indent 2 spaces, no tabs
- No indent for `namespace` blocks
- Use `.clang-format` for formatting new code
- When modifying existing files, format only the lines you changed (not the entire file)
- `.clang-format` handles include sorting automatically for new/modified code
- Most IDEs can format on save; configure to format selection only
- Avoid pure "formatting commits" that touch many files without functional changes

### File Headers
- All source files must start with license header:
  ```cpp
  // SPDX-License-Identifier: GPL-2.0-or-later
  // Copyright The XCSoar Project
  ```
- Header files should use `#pragma once` (not `#ifndef`/`#define` guards)
- Include ordering:
  1. License header
  2. `#pragma once` (for headers)
  3. Local includes (quoted, e.g., `#include "Local.hpp"`)
  4. System includes (angled, e.g., `#include <array>`)
  5. Conditional includes (`#ifdef` blocks)
- `.clang-format` handles include sorting automatically

### Naming Conventions
- Classes/functions: `CamelCase` (not `camelCase`)
- Variables/attributes: `lowercase_with_underscores` (e.g., `foo_bar`)
- Constants/enums: `UPPER_CASE` (e.g., `FOO_BAR`)
- Files: `*.cpp` and `*.hpp` for C++, named after the main class
- Each class should have separate `.cpp` and `.hpp` files

### C++ Standards
- C++20 standard
- Compilers: gcc 10+ or clang 12+
- Be `const`-correct; use `constexpr` instead of `const` whenever possible
- Use `static` whenever possible
- Make methods `virtual` only after careful consideration
- All overrides must use `override` keyword; use `final` often
- Compile with `WERROR=y` and fix all warnings
- Use `noexcept` for functions that don't throw exceptions
- Use GCC attributes when appropriate: `[[gnu::pure]]`, `[[gnu::const]]`, `[[noreturn]]`, `[[nodiscard]]`

### Code Organization
- In class declaration: attributes first, then constructor/destructor, then methods
- Don't write large functions; split them up when they become too large
- Avoid dynamic allocation; use `StaticArray` and `StaticString` if possible
- Asterisks belong to variable name: `Foo *a, *b` not `Foo* a, b`
- Avoid preprocessor macros; use `inline` functions and `constexpr` variables
- Avoid expensive STL containers; prefer `StaticArray`/`StaticString` if size is predictable
- Avoid template hell; keep templates readable

### Enums with Count Values
- Enums that are used in multiple places (backend and UI) should include a `COUNT` sentinel value as the last enum member
- Arrays, lookup tables, or other data structures that correspond to enum values must be guarded with `static_assert` to ensure they match the enum `COUNT`
- This provides compile-time checking to catch mismatches when enum values are added or removed
- Example:
  ```cpp
  enum class MyEnum {
    VALUE1,
    VALUE2,
    COUNT  // sentinel
  };
  
  static const TCHAR *const names[] = {
    _T("Value 1"),
    _T("Value 2"),
  };
  
  static_assert(ARRAY_SIZE(names) == unsigned(MyEnum::COUNT),
                "Array size must match enum COUNT");
  ```

### Comments & Documentation
- Write comments in English
- Comments should be used reasonably:
  - When the code below is complex and not easily human readable
  - When there are things that must be known outside the codebase (e.g., device behavior, protocol specifications, hardware quirks)
  - Avoid obvious comments that just restate what the code does
- Document all workarounds
- Non-trivial functions should have doxygen comments
- Don't abuse multiple `//` comments for multi-line comments

### String Translation
- All strings displayed to the user must be marked as translatable
- Use `_()` macro for strings that are translated immediately: `_("Text")`
- Use `N_()` macro for strings in static arrays/initializers that are translated later via `gettext()`: `N_("Text")`
- Example with `N_()`:
  ```cpp
  static constexpr const TCHAR *const names[] = {
    N_("Value 1"),
    N_("Value 2"),
  };
  // Later, when displaying: gettext(names[i])
  ```
- `N_()` is commonly used with `StaticEnumChoice` arrays for enum dropdowns; `AddChoices()` automatically calls `gettext()` on these strings
- **Logging is exempt**: Do not use translation macros (`_()` or `N_()`) in logging functions (e.g., `LogFormat()`, `LogDebug()`, `LogInfo()`, `LogError()`)
- Log messages should remain in English for consistency and debugging

### Utilities
- Use utility functions in `src/util` when available

### Error Handling
- Exceptions are used for error handling (std::exception, std::runtime_error, etc.)
- Use `std::exception_ptr` for exception propagation across threads
- Use utility functions from `util/Exception.hxx` for exception handling
- For unreachable code, use `gcc_unreachable()` or `assert(false)`
- Use `assert()` for runtime checks in debug builds

## Git Workflow

### General Rules
- **DO NOT autocommit** - Never automatically commit changes without explicit user request
- Always wait for explicit user instruction before creating commits
- Stage changes with `git add` only when requested by the user
- Create commits only when the user explicitly asks for them

### Branches
- `master`: development branch for next minor release
- `v<major>.<minor>.x`: current minor version branch (for bug fixes)
- Commits for next minor release → `master`
- Bug fixes for current minor release → current minor branch

### Patches
- Must be self-explanatory with good description
- Subject line: subsystem/library name + brief description
- **Every commit must compile** - The codebase must be in a buildable state after each commit
- Must compile and not introduce regressions
- Must be self-contained; only change one thing
- Split larger patches into smaller pieces
- Don't refactor and add/modify/remove features in the same patch
- Don't rewrite code unless needed; migrate incrementally

### Commit Messages
- Format: `<Component>:` or `<File Path>:` `<commit message summary>`
- **Path Format Rules:**
  - **DO NOT include `src/` prefix** (e.g., `InfoBoxes/InfoBoxWindow:` not `src/InfoBoxes/InfoBoxWindow:`)
  - **Single file changes**: Use relative path from src/ without extension for .cpp/.hpp
    - ✅ `Device/Driver/Flarm/Logger: Fix buffer overflow`
    - ❌ `src/Device/Driver/Flarm/Logger.cpp: Fix buffer overflow`
  - **Component changes**: Use component directory only
    - ✅ `Device/Driver/Flarm: Update protocol parser`
  - **Build system**: Use file name with extension
    - ✅ `build/wayland.mk: Fix xdg-decoration filename`
  - **Workflow files**: Include path with extension
    - ✅ `.github/workflows/build-native.yml: Add caches`
- **Priority Rules:**
  1. Single file → use component path (no .cpp/.hpp extension, no src/ prefix)
  2. Multiple files in component → use component name
  3. Build/config files → include extension (.mk, .py, .yml, etc.)
- The first line is the summary
- Following lines should provide detailed reasoning and context
- Explain *why* the change is being made, not just *what* changed
- Example:
  ```
  Path: Fix TCHAR to UTF-8 conversion in file I/O

  The file I/O layer was incorrectly handling TCHAR strings on Windows,
  leading to potential buffer overflows. This change uses the Path
  abstraction to ensure safe conversion at the API boundary.
  ```

### Common Commit Message Patterns

**Good examples:**
- `InfoBoxes/InfoBoxWindow: Add visual selection indicator`
- `Dialogs/dlgAnalysis: Fix layout overlap and improve navigation`
- `Device/Driver/Flarm: Update protocol parser`
- `build/wayland.mk: Fix xdg-decoration filename`
- `po: Update translations and fix incorrect msgid associations`
- `.github/workflows/build-native.yml: Add caches for Android builds`
- `.cursor/rules: Add translation and git workflow guidelines`

**Bad examples (and why):**
- ❌ `Fix bug` - No component, no context
- ❌ `Update code` - Too vague
- ❌ `src/InfoBoxes/InfoBoxWindow.cpp: ...` - Don't include `src/` prefix
- ❌ `Fixed the window sizing` - Use present tense ("Fix", not "Fixed")
- ❌ `InfoBox updates` - Be specific about what was changed
- ❌ `WIP: testing stuff` - Clean up before PR submission

## Architecture

### Multi-Platform Considerations
- XCSoar is a multi-platform project supporting: Windows (PC, WIN64), Linux/UNIX, Android, iOS, macOS, Kobo e-readers, Raspberry Pi, and other embedded platforms
- **Unicode/Non-Unicode handling:**
  - Use `TCHAR` for character types (maps to `char` on Unix/Android/iOS, `wchar_t` on Windows with `_UNICODE`)
  - Use `_T()` macro for string literals (e.g., `_T("Hello")`)
  - Use `tstring` (maps to `std::string` or `std::wstring` depending on build)
  - On Windows: can be built with or without `_UNICODE` (Unicode vs ANSI)
  - On Unix/Android/iOS: always uses UTF-8 (`char`, non-Unicode build)
  - Use conversion utilities (`WideToUTF8Converter`, `UTF8ToWideConverter`) when interfacing between different string types
- **File Path Handling:**
  - **Use `Path` class for all file paths** - This is the primary abstraction for file paths across the codebase
  - `Path` class automatically handles TCHAR differences:
    - On Windows (Unicode build): `Path::char_type` = `wchar_t` (UTF-16)
    - On Unix/Android/iOS: `Path::char_type` = `char` (UTF-8)
  - **File I/O conversion boundary**: File I/O operations (`FileOutputStream`, `FileReader`, `FileUtil`) are the single conversion point
    - On Windows: Convert `Path` to UTF-16 for Windows APIs (`CreateFileW()`, `FindFirstFileW()`, etc.)
    - On Unix: Use `Path::c_str()` directly (already UTF-8)
  - Use `Path::ToUTF8()` when you need UTF-8 string representation
  - **Best practice**: Always use `Path` or `AllocatedPath` for file paths, never raw `TCHAR*` or `char*` strings
  - Example:
    ```cpp
    // Good: Use Path class
    AllocatedPath file_path = LocalPath(_T("config.prf"));
    FileOutputStream fos(file_path, FileOutputStream::Mode::CREATE);
    
    // Avoid: Raw TCHAR* for file paths
    // TCHAR *file_path = _T("config.prf");  // Don't do this
    ```
- **Platform detection:**
  - Use `#ifdef ANDROID`, `#ifdef __APPLE__`, `#ifdef WIN32`, `#ifdef KOBO`, etc. for platform-specific code
  - Use helper functions from `Asset.hpp`: `IsAndroid()`, `IsIOS()`, `IsKobo()`, `IsEmbedded()`, etc.
  - Use `HAVE_*` defines for optional features (e.g., `HAVE_NOAA`, `HAVE_SKYLINES_TRACKING`)
- **Platform-specific implementations:**
  - Different implementations may be needed for the same functionality (e.g., audio players, file I/O, threading)
  - Use factory patterns or conditional compilation to select appropriate implementation
  - Test changes on multiple platforms when possible
- **E-paper renderer (Kobo e-readers):**
  - Kobo e-readers use e-paper (E-Ink) displays which are non-color and have special rendering requirements
  - Use `IsKobo()` or `HasEPaper()` from `Asset.hpp` to detect e-paper displays
  - E-paper displays are slow to refresh and show ghosting; animations should be disabled
  - The renderer uses greyscale mode with optional dithering for better visual quality
  - Use `IsDithered()` to check if dithering is enabled for conditional styling
  - Consider display refresh limitations when implementing UI updates on Kobo

### Architectural Layers

XCSoar follows a layered architecture with clear separation of concerns:

**1. Foundation Layer** (`util/`, `Math/`, `Geo/`)
- Low-level utilities with no dependencies on higher layers
- Pure data structures and algorithms
- Can be used by any layer above
- **MUST NOT** include or depend on `Engine/`, `Computer/`, `Device/`, `Blackboard/`, or UI headers

**2. Engine Layer** (`Engine/`)
- Business logic: task calculations, airspace, waypoints, route planning
- Independent of UI and platform-specific code
- Minimal dependencies; should not depend on UI or backend layers
- Provides abstract interfaces (e.g., `TaskInterface`) for flexibility

**3. Backend Layer** (`Computer/`, `Device/`, `Blackboard/`, `CalculationThread/`)
- Sensor data processing and merging
- Expensive calculations (task engine, airspace warnings)
- Thread management and data synchronization
- Uses `BackendComponents` to manage backend resources
- **MUST NOT** directly access UI components (`Dialogs/`, `Form/`, `Widget/`)
- **MUST NOT** call `CommonInterface` or `ActionInterface` (these are UI-thread only)
- Device drivers **MUST NOT** include UI headers or show dialogs
- CalculationThread **MUST NOT** access UI components
- For Backend→UI communication, use `InputEvents::processGlideComputer()` event queue (see below)

**4. Interface/UI Layer** (`Interface.hpp`, `Dialogs/`, `Form/`, `Renderer/`, `MapWindow/`)
- User interface and presentation
- Reads data through `Interface.hpp` (read-only access)
- Sends actions through `ActionInterface` (UI → Backend communication)
- Uses `Components` to access backend resources when needed

**5. Platform Abstraction Layer** (`ui/`, `thread/`, `net/`, platform-specific directories)
- OS-specific implementations
- Abstracts platform differences
- Higher layers depend on abstractions, not implementations
- **MUST NOT** include or depend on `Engine/`, `Computer/`, `Device/`, or `Blackboard/` headers
- Platform layer should only provide OS abstractions, not business logic

### Clean Interface Principles

**Blackboard Pattern for Data Sharing:**
- `DeviceBlackboard`: shared between device threads and calculation threads
- `InterfaceBlackboard`: read-only copy for UI thread (via `CommonInterface::Basic()`)
- `MapWindowBlackboard`: for map rendering thread
- Each thread has its own blackboard copy to avoid locking overhead
- Use `BlackboardListener` for UI components that need change notifications

**Component Separation:**
- `BackendComponents`: manages backend resources (devices, computers, threads)
- `DataComponents`: manages data stores (waypoints, airspaces, terrain)
- `NetComponents`: manages network resources
- Components are accessed through global pointers, not direct dependencies

**Interface Access Patterns:**
- **UI reading data**: Use `CommonInterface::Basic()` or `CommonInterface::Calculated()` (read-only, thread-safe for UI thread)
- **UI modifying settings**: Use `ActionInterface` functions (e.g., `ActionInterface::SetMacCready()`)
- **Backend accessing data**: Lock and read from `DeviceBlackboard` or use appropriate blackboard
- **Engine layer**: Should not depend on UI or backend; accessed through abstract interfaces

**Dependency Rules:**
- Foundation → no dependencies (MUST NOT depend on higher layers)
- Engine → only Foundation (util, Math, Geo) (MUST NOT depend on Backend or UI)
- Backend → Foundation + Engine (MUST NOT depend on UI directly)
- UI → Foundation + Engine + Backend (through interfaces)
- Platform → Foundation only (MUST NOT depend on business logic layers)

**Layer-Specific Restrictions:**
- **Device drivers**: MUST NOT access UI (`Dialogs/`, `Form/`, `CommonInterface`, `ActionInterface`)
- **Device drivers**: MUST NOT directly call `GlideComputer`, `BasicComputer`, or `CalculationThread`
- **CalculationThread**: MUST NOT access UI components
- **Foundation layer**: MUST NOT include headers from `Engine/`, `Computer/`, `Device/`, `Blackboard/`, or UI
- **Platform layer**: MUST NOT include headers from `Engine/`, `Computer/`, `Device/`, or `Blackboard/`

**Thread Safety:**
- UI thread: use `InterfaceBlackboard` via `CommonInterface::*()` functions
- Calculation thread: use `GlideComputerBlackboard` or lock `DeviceBlackboard`
- Map rendering thread: use `MapWindowBlackboard`
- Device threads: write to `DeviceBlackboard` (per-device slots), then notify merge thread
- Never access `InterfaceBlackboard` from non-UI threads

### Blackboard Usage Guide

**DeviceBlackboard** (Backend, Device threads):
- Ground truth state with single mutex for fast access
- Device threads write to `per_device_data[i]` via `LockSetDeviceDataScheduleMerge()`
- MergeThread reads and merges data
- Use `LockGetDeviceDataUpdateClock(i)` to read device data with clock update
- Never access from UI thread directly - use `CommonInterface` instead
- Always lock with `const std::lock_guard lock{device_blackboard.mutex}` when accessing from device/calculation threads
- Device drivers can implement two callbacks:
  - `OnSensorUpdate()`: Called from MergeThread (mutex locked), for forwarding sensor data quickly
  - `OnCalculatedUpdate()`: Called from UI thread, for sending calculated data (task info, glide polar) to device

**InterfaceBlackboard** (UI thread only):
- Read-only copy accessed via `CommonInterface::Basic()` and `CommonInterface::Calculated()`
- Automatically updated by `XCSoarInterface::ReceiveGPS()` and `ReceiveCalculated()`
- Use `BlackboardListener` to get notified of changes
- Assert `InMainThread()` - never access from other threads
- This is the primary interface for all UI code (InfoBoxes, dialogs, widgets)

**MapWindowBlackboard** (Draw thread only):
- Read-only copy for map rendering
- Assert `InDrawThread()` - never access from other threads
- Contains `fading_flarm_traffic` map for disappearing traffic
- Updated by `MapWindow::ReadBlackboard()` from `InterfaceBlackboard`

**GlideComputerBlackboard** (CalculationThread):
- Used by CalculationThread for expensive calculations
- Receives data from DeviceBlackboard
- Writes calculated results back to DeviceBlackboard

### Data Flow Architecture

**Sensor Data Flow:**
1. Device threads parse NMEA → write to `DeviceBlackboard::per_device_data[i]`
2. Call `LockSetDeviceDataScheduleMerge()` to trigger merge
3. MergeThread (50ms interval) merges data and runs BasicComputer
4. CalculationThread (max 2x/sec) reads from DeviceBlackboard, runs GlideComputer
5. UI thread calls `XCSoarInterface::ReceiveGPS()` / `ReceiveCalculated()`
6. Data copied to InterfaceBlackboard, BlackboardListeners notified
7. Draw thread reads from MapWindowBlackboard

**Settings Flow:**
- UI modifies settings via `ActionInterface::*()` functions
- Settings propagate to DeviceBlackboard and then to devices
- Use `to_devices=true` parameter to send to hardware devices
- Settings are also saved to profile via `Profile::Set()` when appropriate

**Thread Flow:**
```
Device Threads → MergeThread → CalculationThread → UI Thread → Draw Thread
```

### Backend→UI Event Queue

**Pattern**: Backend code should NOT directly access UI components. Instead, use the event queue pattern for Backend→UI communication.

**Mechanism**: `InputEvents::processGlideComputer()`
- Backend code (e.g., `GlideComputer`, `ConditionMonitor`) calls `InputEvents::processGlideComputer(gce_id)` to queue events
- Events are queued and processed later by `InputEvents::DoQueuedEvents()` in the UI thread
- This is an **asynchronous event queue pattern** that maintains proper layer separation
- Events are defined in `Input/InputQueue.hpp` (e.g., `GCE_TASK_START`, `GCE_AIRSPACE_ENTER`)

**Example**:
```cpp
// In Backend code (e.g., GlideComputer, ConditionMonitor)
void TaskFinish() noexcept {
  InputEvents::processGlideComputer(GCE_TASK_FINISH);
  // Event is queued, will be processed in UI thread
}

// UI thread processes events via InputEvents::DoQueuedEvents()
// which calls processGlideComputer_real() to handle the event
```

**When to use**:
- Backend needs to notify UI of state changes (task start/finish, airspace warnings, etc.)
- Backend should NOT directly show dialogs or access UI components
- This pattern maintains proper layer separation while allowing Backend→UI communication

### Thread-Specific Code Patterns

**Device Driver Thread:**
```cpp
// In device driver's data handler (parsing incoming NMEA)
auto basic = blackboard.LockGetDeviceDataUpdateClock(index);
// Parse NMEA and update basic
// Update basic with parsed data (e.g., basic.location = ...)
blackboard.LockSetDeviceDataScheduleMerge(index, basic);
```

**Device Driver Callbacks:**
```cpp
// OnSensorUpdate: Called from MergeThread (with DeviceBlackboard mutex locked)
// Use for drivers that need to forward sensor data quickly (e.g., analog vario needle)
void OnSensorUpdate(const MoreData &basic) override {
  // Must not block, mutex is already locked
  // Forward sensor data to device quickly
}

// OnCalculatedUpdate: Called from UI thread (main thread) after CalculationThread run
// Use for drivers that need calculated data (task info, glide polar, etc.) to send to device
void OnCalculatedUpdate(const MoreData &basic,
                        const DerivedInfo &calculated) override {
  // Send calculated data to device (e.g., task information, glide polar)
  // Examples: VegaDevice, LXEosDevice, OpenVarioDevice
}
```

**UI Thread (InfoBox, Dialog, Widget):**
```cpp
// Read data (always use CommonInterface, never DeviceBlackboard)
const MoreData &basic = CommonInterface::Basic();
const DerivedInfo &calculated = CommonInterface::Calculated();

// Modify settings
ActionInterface::SetMacCready(mc, to_devices);

// Listen for changes
class MyWidget : public BlackboardListener {
  void OnGPSUpdate() override { /* refresh display */ }
  void OnCalculatedUpdate() override { /* update calculations */ }
};
// Register: blackboard.AddListener(*this);
// Unregister: blackboard.RemoveListener(*this);
```

**CalculationThread:**
```cpp
// Read from DeviceBlackboard (with lock)
const std::lock_guard lock{device_blackboard.mutex};
const MoreData &basic = device_blackboard.Basic();
// Perform calculations, write to GlideComputerBlackboard
```

**Map Rendering Thread:**
```cpp
// Read from MapWindowBlackboard (no lock needed, local copy)
const MoreData &basic = map_blackboard.Basic();
const DerivedInfo &calculated = map_blackboard.Calculated();
// Render map using this data
```

### Component Access Patterns

**Accessing Backend Components:**
```cpp
// Use global pointer (defined in Components.hpp)
if (backend_components != nullptr) {
  auto &device_blackboard = *backend_components->device_blackboard;
  // Access with lock
  const std::lock_guard lock{device_blackboard.mutex};
  // ...
}
```

**Accessing Data Components:**
```cpp
if (data_components != nullptr) {
  auto *waypoints = data_components->waypoints.get();
  auto *airspaces = data_components->airspaces.get();
  // ...
}
```

**Always check for nullptr** - components may not be initialized in all contexts (e.g., during startup/shutdown, in unit tests)

### Common Architectural Pitfalls

**DO NOT:**
- Access `InterfaceBlackboard` or `CommonInterface::*()` from non-UI threads
- Access `DeviceBlackboard` directly from UI thread (use `CommonInterface` instead)
- Add UI dependencies to Engine layer code
- Add Backend dependencies to Engine layer code
- Access components without checking for nullptr
- Forget to lock DeviceBlackboard when reading from device/calculation threads
- Use `DeviceBlackboard` in MapWindow rendering (use `MapWindowBlackboard`)
- Call `CommonInterface::*()` from device drivers or calculation threads
- Include UI headers (`Dialogs/`, `Form/`, `Widget/`) in device drivers or Backend code
- Call `ActionInterface` from device drivers or calculation threads
- Include `Engine/`, `Computer/`, `Device/`, or `Blackboard/` headers in Foundation or Platform layers
- Directly show dialogs or message boxes from Backend code (use event queue instead)

**DO:**
- Use `CommonInterface::*()` in UI code
- Use `ActionInterface::*()` for UI actions
- Lock DeviceBlackboard when accessing from device/calculation threads
- Use appropriate blackboard for each thread
- Register/unregister BlackboardListeners properly
- Check component pointers for nullptr
- Use `InMainThread()`, `InDrawThread()` assertions to verify thread context

### Adding a New Device Driver

1. Create driver class in `Device/Driver/YourDevice/`
2. Implement `Device` interface methods
3. Parse incoming data into `NMEAInfo` structure
4. Write to DeviceBlackboard:
   ```cpp
   auto basic = blackboard.LockGetDeviceDataUpdateClock(index);
   // Update basic with parsed data
   basic.location = parsed_location;
   basic.gps.fix_quality = FixQuality::GPS;
   // ... update other fields
   blackboard.LockSetDeviceDataScheduleMerge(index, basic);
   ```
5. Handle outgoing commands via `WriteNMEA()` or binary protocol
6. Implement callbacks if needed:
   - `OnSensorUpdate()`: For drivers that forward sensor data quickly (called from MergeThread)
   - `OnCalculatedUpdate()`: For drivers that send calculated data to device (called from UI thread)
7. Register driver in `Device/Driver/Register.cpp`
8. Add device configuration widget in `Dialogs/Device/YourDevice/` if needed

### Source Organization
- Code in `src/` directory with specific subdirectories (util/, Math/, Geo/, etc.)

### Threading
- UI thread: main thread, no other thread may manipulate windows
- Access sensor data from `CommonInterface::Basic()` in UI thread only
- Other threads must not use `Interface.hpp` library
- Use appropriate blackboards for different threads:
  - UI thread: `InterfaceBlackboard` via `CommonInterface::Basic()`
  - MapWindow (DrawThread): `MapWindowBlackboard`
  - Device drivers: write to `DeviceBlackboard::per_device_data[i]`, can implement `OnSensorUpdate()` (called from MergeThread) or `OnCalculatedUpdate()` (called from UI thread)
  - CalculationThread: lock `DeviceBlackboard` or use `GlideComputerBlackboard`

## Privacy

### Network Activity and Tracking
- XCSoar operates offline by default; no network activity unless explicitly enabled by the user
- Network features (e.g., tracking services, weather downloads) must be opt-in and clearly documented
- No automatic tracking, telemetry, or analytics
- All network features should be clearly visible in settings and require user consent
- When implementing network features, respect user privacy settings and provide clear opt-out mechanisms

### Data Logging
- Avoid logging identifying or sensitive information:
  - Usernames, passwords, or authentication tokens
  - Device serial numbers or unique identifiers
  - Personal information that could identify users
- Log files (IGC, NMEA) contain flight data only; no personal identifiers should be embedded
- Debug logs should not contain sensitive data; sanitize or exclude passwords, tokens, and personal information
- When logging is necessary for debugging, use sanitized or anonymized data

### User Data Protection
- All user data is stored locally on the device
- No automatic transmission of user data to external servers
- User must explicitly choose to share data (e.g., upload IGC files, enable tracking)
- Respect user privacy preferences and settings

## GUI Guidelines

### UI Scaling and DPI Support
- UI must scale from low-DPI devices (e.g., CGA resolution ~96 DPI) to very high-DPI devices (e.g., modern phones with 400+ DPI)
- Use `Layout::Scale()` for general UI element scaling (based on 240x320 base resolution)
- Use `Layout::PtScale()` for physical dimensions in points (1/72th inch)
- Use `Layout::VptScale()` for virtual points (accounts for viewing distance on small screens)
- Use `Layout::FontScale()` for font sizes (accounts for DPI, screen size, and user preference)
- Use `Layout::ScalePenWidth()` or `Layout::ScaleFinePenWidth()` for line widths
- Never use hardcoded pixel values; always use scaling functions from `Layout` namespace
- Base resolution: 240 pixels (320 for square displays) on the shortest dimension
- Small screens (< 5 inch) automatically get adjusted scaling for viewing distance
- Touch screens get larger hit areas and control heights
- Test UI changes on both low-DPI and high-DPI devices when possible

### UI Operability
- UI must be operable via multiple input methods: touch, keyboard, and gestures
- All user actions should be accessible through different input modalities
- Expose functionality that makes sense via `ActionInterface` namespace (e.g., `ActionInterface::SetMacCready()`, `ActionInterface::SetBallast()`)
- `ActionInterface` provides a clean API for UI actions that can be triggered by various input methods (touch, keyboard shortcuts, gestures, InputEvents)
- This allows the same functionality to be accessible regardless of input method
- Consider exposing commonly used actions through `ActionInterface` for consistency and accessibility
- **Navigation depth**: All actions used in-flight should be maximum 3 steps away from the main operation mode
- This ensures critical functions remain quickly accessible during flight operations
- Prioritize frequently used in-flight actions to be accessible with fewer steps
- **State change notifications**: Announce internal state changes to the user
- Use appropriate notification mechanisms (e.g., `StatusMessage`, `PopupMessage`, `OperationEnvironment::SetText()`) to inform users of important state changes
- Examples: GPS connection status, device connection/disconnection, task state changes, airspace warnings, system errors
- Ensure users are aware of changes that affect system behavior or require their attention

### Letter Cases
- Captions: Capitalization (e.g., "Pan On", "The Display Of...")
- Abbreviations: Upper case (e.g., "MC", "ETA", "V") or CamelCase (e.g., "GoTo", "InfoBox")
- Plain text: Write like prose
- Labels: Generally like prose, with exceptions where meaningful

### Colors
- Red: warning
- Orange: caution
- Green: positive safety indicator
- Blue: neutral safety indicator
- Grey: buttons
- Yellow: clicked items
- Light blue: key focused item
- Medium blue: dialogue title bar

### Safety
- Avoid elements that encourage continuous screen staring
- Avoid controls with significant risk if misconfigured
- Check for color blindness compatibility
- Follow aviation conventions (ICAO standards, IGC standards, NASA color usage, FAA guidelines)

## Look System

### Look Class Structure
- Look classes are `struct` types (not `class`), named with `*Look` suffix (e.g., `ButtonLook`, `DialogLook`, `MapLook`)
- The main `Look` struct in `src/Look/Look.hpp` aggregates all individual Look structs as members
- Each Look struct contains visual elements: `Pen`, `Brush`, `Color`, `Icon`, `Bitmap`, `Font` pointers, etc.
- Look structs are organized by UI component (e.g., `MapLook`, `InfoBoxLook`, `TaskLook`)

### Look Initialization
- Use `Initialise()` method (British spelling) for initial setup
- Use `Reinitialise()` or `ReinitialiseLayout()` for updates when settings change
- `Initialise()` methods typically take:
  - Settings structs (e.g., `UISettings`, `MapSettings`, `AirspaceRendererSettings`)
  - Font references (e.g., `const Font &font`, `const Font &bold_font`)
  - Layout parameters (e.g., `unsigned infobox_width`)
  - Dark mode flag (`bool dark_mode`)
- The main `Look::InitialiseConfigured()` method initializes all Look structs based on user settings
- Platform-aware initialization: use `IsDithered()`, `HasColors()`, etc. from `Asset.hpp` for conditional styling

### Look Naming and Organization
- Each Look struct should have its own `.hpp` and `.cpp` files in `src/Look/`
- Look structs should be included in the main `Look.hpp` file
- Member variables in Look structs use descriptive names (e.g., `standard`, `selected`, `focused` for button states)
- Use nested structs for related groups (e.g., `StateLook` within `ButtonLook`)

### Colors and Styling
- Use colors from `src/Look/Colors.hpp` for consistency
- Follow color conventions (red=warning, orange=caution, green=safety, blue=neutral)
- Support dark mode when applicable (pass `dark_mode` parameter to `Initialise()`)
- Use platform detection for conditional styling (dithered displays, color vs monochrome)

## Translation and Internationalization Workflow

### Working with .po Files
- Translation files are located in `po/` directory (33 language files + `xcsoar.pot` template)
- Use `make update-po` to synchronize all `.po` files with source code changes
- **CRITICAL**: Never add custom comments (e.g., `# FIXME:`, `# TODO:`) between `#, fuzzy` and `msgid`, or between `msgid` and `msgstr`
- Valid comment placement: Before `#, fuzzy` or at the start of an entry block
- Comments violating `.po` syntax will cause `msgmerge` to fail during `make update-po`

### Translation Commit Organization
- Translation updates should be committed as a single, comprehensive commit
- Translation commits should generally be at the end of a feature branch
- Commit message format: `po: <brief summary of what was translated/fixed>`
- Include detailed description of what was fixed across which languages
- Use `make update-po` before committing translations to ensure line numbers are current
- Example commit structure:
  ```
  po: Update translations and fix incorrect msgid associations
  
  - Fix empty c-format translations for "%s: %s" across 30 languages
  - Correct Hungarian translations for airspace and task messages
  - Fix Croatian typo: "Iskjučen" → "Isključen"
  - Translate new strings ("XCSoar data path", "Click to view...") into all 33 languages
  - Update line number references via make update-po
  ```

### Translation Best Practices
- When adding new translatable strings, translate them into all 33 languages if possible
- Check for empty `msgstr` values in c-format strings (these cause blank UI text)
- Verify translations are semantically correct, not just syntactically valid
- Be aware of common translation confusion patterns (e.g., "No alternates available" vs "Update available")
- Use native speaker review when possible for quality assurance
- Test UI with translations enabled to catch display issues

### Running make update-po
- Run `make update-po` after any source code changes that add/modify translatable strings
- This updates:
  - Line number references in all `.po` files
  - Adds new `msgid` entries from source code
  - Marks changed strings as `#, fuzzy`
  - Updates the `po/xcsoar.pot` template
- Always commit `po/xcsoar.pot` along with `.po` file changes
- Review the diff after `make update-po` to catch any unintended changes

### What make update-po Actually Does

Under the hood, `make update-po` runs these operations:
1. Extracts all `_()` and `N_()` strings from source code → `po/xcsoar.pot`
2. For each `.po` file, runs `msgmerge` to:
   - Update line number references where strings are used
   - Add new `msgid` entries from source
   - Mark modified strings as `#, fuzzy` (needs review)
   - Remove obsolete entries (moved to bottom with `#~`)
3. Preserves existing translations (`msgstr` values)

**Important:** This is why `.po` syntax must be perfect - `msgmerge` is a strict parser!

### Debugging make update-po Failures

If `make update-po` fails with syntax errors:
1. Error will show which `.po` file and line number
2. Common causes:
   - Custom comments between `msgid` and `msgstr`
   - Malformed multiline strings
   - Missing quotes or escaped characters
3. Fix the syntax error and re-run
4. Use `msgfmt --check po/xx.po` to validate individual files
5. If multiple files are affected, fix them all before re-running `make update-po`

## Git History Management

### Interactive Rebase Best Practices
- Use `git rebase -i` for cleaning up commit history before submitting PRs
- Common cleanup operations:
  - **Squash**: Combine related commits (e.g., "Add feature" + "Fix feature" → single commit)
  - **Fixup**: Silently merge fixes into parent commits (auto-discards commit message)
  - **Reword**: Fix commit messages to follow project format
  - **Drop**: Remove commits (e.g., duplicates, reverted changes)
- Set `GIT_SEQUENCE_EDITOR` to automate rebase todo lists for scripted rebases
- Use `GIT_EDITOR=true` or `GIT_EDITOR=cat` to skip interactive editor prompts when commit message is already prepared

### Handling Rebase Conflicts
- When rebasing causes conflicts:
  1. Use `git status` to identify conflicted files
  2. For simple cases, use `git checkout --ours` or `git checkout --theirs`
  3. For translation files (`.po`), usually accept `--theirs` (the final translation commit)
  4. Always use `git add <resolved-files>` before continuing
  5. Use `git rebase --continue` to proceed
- If rebase becomes too complex, use `git rebase --abort` and try a different approach
- Consider breaking complex rebases into phases (e.g., reword → squash → cleanup)

### Commit Cleanup Patterns
- **Identify fixup candidates**: Look for sequential commits that modify the same component
- **Check for duplicates**: Compare commit timestamps and diffs to find exact duplicates
- **Find merge conflict fixes**: Look for commits with "merge conflict" or "fix conflict" that should be squashed into parent
- **Verify commit message format**: Scan for commits missing component prefixes or using generic "Fix"/"Update" subjects
- Use `git log --format="%H %s" --reverse` for scripting commit analysis
- Use `git diff-tree` to compare commit contents when checking for duplicates

### Cleanup Workflow Example
```bash
# Phase 1: Reword commit messages only (safest, no structural changes)
# Phase 2: Squash related commits (e.g., 3 related fixes into 1)
# Phase 3: Drop duplicates and fixup merge conflicts
# Phase 4: Verify final history with git log --oneline
```

### Handling Translation Commit Conflicts
- Translation commits often conflict during rebases (33+ files modified)
- Strategy: Accept `--theirs` for all `.po` and `.pot` files (the final translation state)
- Use: `git checkout --theirs po/*.po po/xcsoar.pot && git add po/`
- This preserves the comprehensive translation commit at the end of the branch

## Build System Debugging

### Makefile Issues
- Build system is in `build/` directory with modular `.mk` files
- Each `.mk` file handles a specific library, feature, or platform (e.g., `build/wayland.mk`, `build/alsa.mk`)
- Generated files are tracked via variables like `WAYLAND_GENERATED`, `SDL_GENERATED`
- When debugging "No rule to make target" errors:
  1. Check if the expected target file exists in the variable definition
  2. Verify filenames match between generation rules and target rules
  3. Look for typos in intermediate file names (e.g., `-code.c` vs `-public.c`)

### Common Build Issues
- **Missing dependencies**: Check `*_LDLIBS` variables for required libraries
- **Protocol generation**: Wayland/SDL code generation must match expected output filenames
- **Cross-compilation**: Different platforms have different `.mk` includes; check `build/detect.mk`
- Use `make V=1` for verbose output to see actual command lines
- Check `build/options.mk` for feature flags that might need to be enabled

### Platform-Specific Builds
- Each platform may have platform-specific files in subdirectories (e.g., `src/ui/window/wayland/`, `src/ui/window/gdi/`)
- Use `#ifdef USE_WAYLAND`, `#ifdef USE_X11`, `#ifdef ANDROID` for conditional compilation
- Test changes on multiple platforms when possible (at minimum: Linux, Windows, Android)
- Pay attention to duplicate symbol definitions across platform implementations

### Platform Code Organization Patterns

XCSoar uses a consistent pattern for platform-specific implementations:

**Directory Structure:**
- `src/ui/window/custom/` - Shared base implementations (fallback/common code)
- `src/ui/window/gdi/` - Windows GDI-specific implementations
- `src/ui/window/wayland/` - Wayland-specific implementations  
- `src/ui/window/x11/` - X11-specific implementations
- `src/ui/window/sdl/` - SDL-specific implementations
- Similar patterns exist in `src/ui/canvas/`, `src/ui/event/`, etc.

**Implementation Pattern:**
1. **Shared base** in `custom/` provides default/common implementation
2. **Platform directories** override specific methods for that platform
3. Build system conditionally compiles appropriate files based on `USE_*` defines
4. Example: `TopWindow.cpp` exists in multiple directories, each compiled for its platform

**When adding platform code:**
- Check if platform-specific directory exists (e.g., `wayland/`, `gdi/`)
- If yes, add implementation there (not in `custom/`)
- If implementing cross-platform feature, add to `custom/` with platform overrides as needed
- Use `#ifdef USE_WAYLAND`, `#ifdef USE_GDI`, etc. for conditional compilation in shared files
- Don't duplicate code - extract common logic to base classes or utility functions

**Common pattern:**
```cpp
// In custom/TopWindow.cpp - base implementation
void TopWindow::SomeMethod() {
  // Default implementation for platforms without specific override
}

// In wayland/TopWindow.cpp - Wayland-specific override
void TopWindow::SomeMethod() {
  // Wayland-specific implementation using Wayland APIs
}
```

### Finding Platform-Specific Implementations

When debugging or extending platform code:
1. Use `find src/ -name "TopWindow.cpp"` to see all platform implementations
2. Check `build/*.mk` files for which files are compiled per platform
3. Look for `#ifdef USE_*` guards in `custom/` files for platform conditionals
4. Grep for platform-specific functions to find where they're implemented:
   ```bash
   rg "CreateNative" src/ui/window/
   ```
5. Build system variables (in `build/detect.mk`) determine which platform is active

**Common platform defines:**
- `USE_GDI` - Windows GDI
- `USE_WAYLAND` - Wayland compositor
- `USE_X11` - X11 windowing
- `USE_SDL` - SDL2 framework
- `ANDROID` - Android platform
- `KOBO` - Kobo e-reader
- `USE_POLL_EVENT` - Poll-based event system (X11, Wayland)
- `USE_FB` - Linux framebuffer

## GitHub PR Review Workflow

### Responding to PR Comments
- Use `gh pr view <number> --comments` to retrieve all review comments programmatically
- Address all comments systematically:
  1. Read all comments first
  2. Categorize: typos, bugs, design issues, questions
  3. Fix issues in separate commits or squash into existing commits
  4. Document fixes in commit messages
- Use `gh pr comment <number>` to respond to specific review threads

### Fixing PR Issues
- **Small fixes** (typos, simple bugs): Either amend into existing commit or create fixup commit
- **Larger issues**: Create properly formatted new commit, then consider squashing during final cleanup
- **Translation issues**: Fix all languages, not just the one mentioned in review
- Document what was changed in response to review (helps reviewers verify fixes)

### Pre-PR Checklist
- Run `make update-po` if any translatable strings were added/modified
- Check that all `.po` files have valid syntax (no custom comments in wrong places)
- Verify commit messages follow format: `<Component>: <Summary>`
- Squash fixup commits and reword generic "Fix" messages
- Ensure branch compiles on at least one platform
- Check for accidentally committed debug code or temporary files

## Common Mistakes and How to Avoid Them

### Translation File Mistakes
- ❌ Adding custom comments between `msgid` and `msgstr`
- ✅ Place comments before `msgid` or at entry start
- ❌ Forgetting to run `make update-po` after source changes
- ✅ Always run `make update-po` before committing translations
- ❌ Translating only one language when fixing an issue
- ✅ Fix the issue across all affected languages

### Git Workflow Mistakes
- ❌ Creating many small fixup commits during development
- ✅ Squash related commits before PR submission
- ❌ Generic commit messages: "Fix bug", "Update code"
- ✅ Use component prefix: "Device/Flarm: Fix buffer overflow"
- ❌ Committing translation files in middle of feature branch
- ✅ Move translation commit to end of branch

### Build System Mistakes
- ❌ Hardcoding filenames without checking generation output
- ✅ Verify generated file names match target rules
- ❌ Adding libraries to wrong `*_LDLIBS` variable
- ✅ Add to correct feature's LDLIBS (e.g., `AUDIO_LDLIBS` for sound)
- ❌ Platform-specific code without proper `#ifdef` guards
- ✅ Use appropriate platform detection macros

### Code Organization Mistakes
- ❌ Including platform-specific headers in cross-platform code
- ✅ Keep platform code in platform-specific directories
- ❌ Implementing platform features in `custom/` when platform-specific files exist
- ✅ Use existing platform directories (e.g., `wayland/TopWindow.cpp`)
- ❌ Duplicating code across platform implementations
- ✅ Extract common code to shared base classes or utilities
