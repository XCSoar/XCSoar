---
alwaysApply: true
---

# XCSoar Project Rules

## Code Style

### Formatting
- 79 columns maximum (reasonable exceptions allowed)
- Indent 2 spaces, no tabs
- No indent for `namespace` blocks
- Use `.clang-format` for formatting new code
- When modifying existing files, format only the lines you changed (not the entire file)
- `.clang-format` handles include sorting automatically for new/modified code
- Most IDEs can format on save; configure to format selection only
- Avoid pure "formatting commits" that touch many files without functional changes

### File Headers
- All source files must start with license header:
  ```cpp
  // SPDX-License-Identifier: GPL-2.0-or-later
  // Copyright The XCSoar Project
  ```
- Header files should use `#pragma once` (not `#ifndef`/`#define` guards)
- Include ordering:
  1. License header
  2. `#pragma once` (for headers)
  3. Local includes (quoted, e.g., `#include "Local.hpp"`)
  4. System includes (angled, e.g., `#include <array>`)
  5. Conditional includes (`#ifdef` blocks)
- `.clang-format` handles include sorting automatically

### Naming Conventions
- Classes/functions: `CamelCase` (not `camelCase`)
- Variables/attributes: `lowercase_with_underscores` (e.g., `foo_bar`)
- Constants/enums: `UPPER_CASE` (e.g., `FOO_BAR`)
- Files: `*.cpp` and `*.hpp` for C++, named after the main class
- Each class should have separate `.cpp` and `.hpp` files

### C++ Standards
- C++20 standard
- Compilers: gcc 10+ or clang 12+
- Be `const`-correct; use `constexpr` instead of `const` whenever possible
- Use `static` whenever possible
- Make methods `virtual` only after careful consideration
- All overrides must use `override` keyword; use `final` often
- Compile with `WERROR=y` and fix all warnings
- Use `noexcept` for functions that don't throw exceptions
- Use GCC attributes when appropriate: `[[gnu::pure]]`, `[[gnu::const]]`, `[[noreturn]]`, `[[nodiscard]]`
- Prefer `fmt::format` over `sprintf`/`snprintf` for string formatting in new code
- Use `LogFmt()` for formatted logging (wraps `fmt` internally)

### Code Organization
- In class declaration: attributes first, then constructor/destructor, then methods
- Don't write large functions; split them up when they become too large
- Avoid dynamic allocation; use `StaticArray` and `StaticString` if possible
- Asterisks belong to variable name: `Foo *a, *b` not `Foo* a, b`
- Avoid preprocessor macros; use `inline` functions and `constexpr` variables
- Avoid expensive STL containers; prefer `StaticArray`/`StaticString` if size is predictable
- Avoid template hell; keep templates readable

### Enums with Count Values
- Enums that are used in multiple places (backend and UI) should include a `COUNT` sentinel value as the last enum member
- Arrays, lookup tables, or other data structures that correspond to enum values must be guarded with `static_assert` to ensure they match the enum `COUNT`
- This provides compile-time checking to catch mismatches when enum values are added or removed
- Example:
  ```cpp
  enum class MyEnum {
    VALUE1,
    VALUE2,
    COUNT  // sentinel
  };
  
  static const char *const names[] = {
    "Value 1",
    "Value 2",
  };
  
  static_assert(ARRAY_SIZE(names) == unsigned(MyEnum::COUNT),
                "Array size must match enum COUNT");
  ```

### Comments & Documentation
- Write comments in English
- Comments should be used reasonably:
  - When the code below is complex and not easily human readable
  - When there are things that must be known outside the codebase (e.g., device behavior, protocol specifications, hardware quirks)
  - Avoid obvious comments that just restate what the code does
- Document all workarounds
- Non-trivial functions should have doxygen comments
- Don't abuse multiple `//` comments for multi-line comments

### String Translation
- All strings displayed to the user must be marked as translatable
- Use `_()` macro for strings that are translated immediately: `_("Text")`
- Use `N_()` macro for strings in static arrays/initializers that are translated later via `gettext()`: `N_("Text")`
- Example with `N_()`:
  ```cpp
  static constexpr const char *const names[] = {
    N_("Value 1"),
    N_("Value 2"),
  };
  // Later, when displaying: gettext(names[i])
  ```
- `N_()` is commonly used with `StaticEnumChoice` arrays for enum dropdowns; `AddChoices()` automatically calls `gettext()` on these strings
- **Logging is exempt**: Do not use translation macros (`_()` or `N_()`) in logging functions (e.g., `LogFormat()`, `LogDebug()`, `LogInfo()`, `LogError()`)
- Log messages should remain in English for consistency and debugging

### Utilities
- Use utility functions in `src/util` when available

### Error Handling
- Exceptions are used for error handling (std::exception, std::runtime_error, etc.)
- Use `std::exception_ptr` for exception propagation across threads
- Use utility functions from `util/Exception.hxx` for exception handling
- For unreachable code, use `gcc_unreachable()` or `assert(false)`
- Use `assert()` for runtime checks in debug builds

## Git Workflow

### General Rules
- **DO NOT autocommit** - Never automatically commit changes without explicit user request
- Always wait for explicit user instruction before creating commits
- Stage changes with `git add` only when requested by the user
- Create commits only when the user explicitly asks for them

### Branches
- `master`: development branch for next minor release
- `v<major>.<minor>.x`: current minor version branch (for bug fixes)
- Commits for next minor release → `master`
- Bug fixes for current minor release → current minor branch

### Patches
- Must be self-explanatory with good description
- Subject line: subsystem/library name + brief description
- **Every commit must compile** - The codebase must be in a buildable state after each commit
- Must compile and not introduce regressions
- Must be self-contained; only change one thing
- Split larger patches into smaller pieces
- Don't refactor and add/modify/remove features in the same patch
- Don't rewrite code unless needed; migrate incrementally

### Commit Messages
- Format: `<Component>:` or `<File Path>:` `<commit message summary>`
- **Path Format Rules:**
  - **DO NOT include `src/` prefix** (e.g., `InfoBoxes/InfoBoxWindow:` not `src/InfoBoxes/InfoBoxWindow:`)
  - **Single file changes**: Use relative path from src/ without extension for .cpp/.hpp
    - ✅ `Device/Driver/Flarm/Logger: Fix buffer overflow`
    - ❌ `src/Device/Driver/Flarm/Logger.cpp: Fix buffer overflow`
  - **Component changes**: Use component directory only
    - ✅ `Device/Driver/Flarm: Update protocol parser`
  - **Build system**: Use file name with extension
    - ✅ `build/wayland.mk: Fix xdg-decoration filename`
  - **Workflow files**: Include path with extension
    - ✅ `.github/workflows/build-native.yml: Add caches`
- **Priority Rules:**
  1. Single file → use component path (no .cpp/.hpp extension, no src/ prefix)
  2. Multiple files in component → use component name
  3. Build/config files → include extension (.mk, .py, .yml, etc.)
- The first line is the summary
- Following lines should provide detailed reasoning and context
- Explain *why* the change is being made, not just *what* changed
- Example:
  ```
  Path: Fix char to UTF-8 conversion in file I/O

  The file I/O layer was incorrectly handling char strings on Windows,
  leading to potential buffer overflows. This change uses the Path
  abstraction to ensure safe conversion at the API boundary.
  ```

### Common Commit Message Patterns

**Good examples:**
- `InfoBoxes/InfoBoxWindow: Add visual selection indicator`
- `Dialogs/dlgAnalysis: Fix layout overlap and improve navigation`
- `Device/Driver/Flarm: Update protocol parser`
- `build/wayland.mk: Fix xdg-decoration filename`
- `po: Update translations and fix incorrect msgid associations`
- `.github/workflows/build-native.yml: Add caches for Android builds`
- `.cursor/rules: Add translation and git workflow guidelines`

**Bad examples (and why):**
- ❌ `Fix bug` - No component, no context
- ❌ `Update code` - Too vague
- ❌ `src/InfoBoxes/InfoBoxWindow.cpp: ...` - Don't include `src/` prefix
- ❌ `Fixed the window sizing` - Use present tense ("Fix", not "Fixed")
- ❌ `InfoBox updates` - Be specific about what was changed
- ❌ `WIP: testing stuff` - Clean up before PR submission

## Architecture

### Multi-Platform Considerations
- XCSoar is a multi-platform project supporting: Windows (PC, WIN64), Linux/UNIX, Android, iOS, macOS, Kobo e-readers, Raspberry Pi, and other embedded platforms
- **String handling (UTF-8 everywhere):**
  - XCSoar uses UTF-8 encoding on all platforms
  - For new code: use `char`, `std::string`, `std::string_view`, plain string literals
  - Legacy code still uses `TCHAR` and `_T()` - these are now aliases for `char` and no-op respectively (defined in `src/unix/tchar.h`)
  - Avoid adding new `TCHAR`/`_T()` usage; migrate incrementally when touching existing code
- **File Path Handling:**
  - **Use `Path` class for all file paths** - This is the primary abstraction for file paths across the codebase
  - `Path::char_type` is now always `char` (UTF-8)
  - On Windows: File APIs use ANSI encoding (system code page); file names should use ASCII characters
  - On Unix: Uses UTF-8 directly via `Path::c_str()`
  - Use `Path::ToUTF8()` when you need UTF-8 string representation
  - **Best practice**: Always use `Path` or `AllocatedPath` for file paths, never raw `char*` strings
  - Example:
    ```cpp
    // Good: Use Path class
    AllocatedPath file_path = LocalPath("config.prf");
    FileOutputStream fos(file_path, FileOutputStream::Mode::CREATE);
    
    // Avoid: Raw char* for file paths
    // char *file_path = "config.prf";  // Don't do this
    ```
- **Platform detection:**
  - Use `#ifdef ANDROID`, `#ifdef __APPLE__`, `#ifdef WIN32`, `#ifdef KOBO`, etc. for platform-specific code
  - Use helper functions from `Asset.hpp`: `IsAndroid()`, `IsIOS()`, `IsKobo()`, `IsEmbedded()`, etc.
  - Use `HAVE_*` defines for optional features (e.g., `HAVE_NOAA`, `HAVE_SKYLINES_TRACKING`)
- **Darwin ARC (Objective-C++):**
  - Darwin builds use ARC (`-fobjc-arc` in `build/darwin.mk`). Do not call manual retain/release APIs (e.g. `release`, `retain`, `autorelease`, `nw_release`) in ARC-compiled code
- **Platform-specific implementations:**
  - Different implementations may be needed for the same functionality (e.g., audio players, file I/O, threading)
  - Use factory patterns or conditional compilation to select appropriate implementation
  - Test changes on multiple platforms when possible
- **E-paper renderer (Kobo e-readers):**
  - Kobo e-readers use e-paper (E-Ink) displays which are non-color and have special rendering requirements
  - Use `IsKobo()` or `HasEPaper()` from `Asset.hpp` to detect e-paper displays
  - E-paper displays are slow to refresh and show ghosting; animations should be disabled
  - The renderer uses greyscale mode with optional dithering for better visual quality
  - Use `IsDithered()` to check if dithering is enabled for conditional styling
  - Consider display refresh limitations when implementing UI updates on Kobo

### Architectural Layers

XCSoar follows a layered architecture with clear separation of concerns:

**1. Foundation Layer** (`util/`, `Math/`, `Geo/`)
- Low-level utilities with no dependencies on higher layers
- Pure data structures and algorithms
- Can be used by any layer above
- **MUST NOT** include or depend on `Engine/`, `Computer/`, `Device/`, `Blackboard/`, or UI headers

**2. Engine Layer** (`Engine/`)
- Business logic: task calculations, airspace, waypoints, route planning
- Independent of UI and platform-specific code
- Minimal dependencies; should not depend on UI or backend layers
- Provides abstract interfaces (e.g., `TaskInterface`) for flexibility

**3. Backend Layer** (`Computer/`, `Device/`, `Blackboard/`, `CalculationThread/`)
- Sensor data processing and merging
- Expensive calculations (task engine, airspace warnings)
- Thread management and data synchronization
- Uses `BackendComponents` to manage backend resources
- **MUST NOT** directly access UI components (`Dialogs/`, `Form/`, `Widget/`)
- **MUST NOT** call `CommonInterface` or `ActionInterface` (these are UI-thread only)
- Device drivers **MUST NOT** include UI headers or show dialogs
- CalculationThread **MUST NOT** access UI components
- For Backend→UI communication, use `InputEvents::processGlideComputer()` event queue (see below)

**4. Interface/UI Layer** (`Interface.hpp`, `Dialogs/`, `Form/`, `Renderer/`, `MapWindow/`)
- User interface and presentation
- Reads data through `Interface.hpp` (read-only access)
- Sends actions through `ActionInterface` (UI → Backend communication)
- Uses `Components` to access backend resources when needed

**5. Platform Abstraction Layer** (`ui/`, `thread/`, `net/`, platform-specific directories)
- OS-specific implementations
- Abstracts platform differences
- Higher layers depend on abstractions, not implementations
- **MUST NOT** include or depend on `Engine/`, `Computer/`, `Device/`, or `Blackboard/` headers
- Platform layer should only provide OS abstractions, not business logic

### Clean Interface Principles

**Blackboard Pattern for Data Sharing:**
- `DeviceBlackboard`: shared between device threads and calculation threads
- `InterfaceBlackboard`: read-only copy for UI thread (via `CommonInterface::Basic()`)
- `MapWindowBlackboard`: for map rendering thread
- Each thread has its own blackboard copy to avoid locking overhead
- Use `BlackboardListener` for UI components that need change notifications

**Component Separation:**
- `BackendComponents`: manages backend resources (devices, computers, threads)
- `DataComponents`: manages data stores (waypoints, airspaces, terrain)
- `NetComponents`: manages network resources
- Components are accessed through global pointers, not direct dependencies

**Interface Access Patterns:**
- **UI reading data**: Use `CommonInterface::Basic()` or `CommonInterface::Calculated()` (read-only, thread-safe for UI thread)
- **UI modifying settings**: Use `ActionInterface` functions (e.g., `ActionInterface::SetMacCready()`)
- **Backend accessing data**: Lock and read from `DeviceBlackboard` or use appropriate blackboard
- **Engine layer**: Should not depend on UI or backend; accessed through abstract interfaces

**Dependency Rules:**
- Foundation → no dependencies (MUST NOT depend on higher layers)
- Engine → only Foundation (util, Math, Geo) (MUST NOT depend on Backend or UI)
- Backend → Foundation + Engine (MUST NOT depend on UI directly)
- UI → Foundation + Engine + Backend (through interfaces)
- Platform → Foundation only (MUST NOT depend on business logic layers)

**Layer-Specific Restrictions:**
- **Device drivers**: MUST NOT access UI (`Dialogs/`, `Form/`, `CommonInterface`, `ActionInterface`)
- **Device drivers**: MUST NOT directly call `GlideComputer`, `BasicComputer`, or `CalculationThread`
- **CalculationThread**: MUST NOT access UI components
- **Foundation layer**: MUST NOT include headers from `Engine/`, `Computer/`, `Device/`, `Blackboard/`, or UI
- **Platform layer**: MUST NOT include headers from `Engine/`, `Computer/`, `Device/`, or `Blackboard/`

**Thread Safety:**
- UI thread: use `InterfaceBlackboard` via `CommonInterface::*()` functions
- Calculation thread: use `GlideComputerBlackboard` or lock `DeviceBlackboard`
- Map rendering thread: use `MapWindowBlackboard`
- Device threads: write to `DeviceBlackboard` (per-device slots), then notify merge thread
- Never access `InterfaceBlackboard` from non-UI threads

### Blackboard Usage Guide

**DeviceBlackboard** (Backend, Device threads):
- Ground truth state with single mutex for fast access
- Device threads write to `per_device_data[i]` via `LockSetDeviceDataScheduleMerge()`
- MergeThread reads and merges data
- Use `LockGetDeviceDataUpdateClock(i)` to read device data with clock update
- Never access from UI thread directly - use `CommonInterface` instead
- Always lock with `const std::lock_guard lock{device_blackboard.mutex}` when accessing from device/calculation threads
- Device drivers can implement two callbacks:
  - `OnSensorUpdate()`: Called from MergeThread (mutex locked), for forwarding sensor data quickly
  - `OnCalculatedUpdate()`: Called from UI thread, for sending calculated data (task info, glide polar) to device

**InterfaceBlackboard** (UI thread only):
- Read-only copy accessed via `CommonInterface::Basic()` and `CommonInterface::Calculated()`
- Automatically updated by `XCSoarInterface::ReceiveGPS()` and `ReceiveCalculated()`
- Use `BlackboardListener` to get notified of changes
- Assert `InMainThread()` - never access from other threads
- This is the primary interface for all UI code (InfoBoxes, dialogs, widgets)

**MapWindowBlackboard** (Draw thread only):
- Read-only copy for map rendering
- Assert `InDrawThread()` - never access from other threads
- Contains `fading_flarm_traffic` map for disappearing traffic
- Updated by `MapWindow::ReadBlackboard()` from `InterfaceBlackboard`

**GlideComputerBlackboard** (CalculationThread):
- Used by CalculationThread for expensive calculations
- Receives data from DeviceBlackboard
- Writes calculated results back to DeviceBlackboard

### Data Flow Architecture

**Sensor Data Flow:**
1. Device threads parse NMEA → write to `DeviceBlackboard::per_device_data[i]`
2. Call `LockSetDeviceDataScheduleMerge()` to trigger merge
3. MergeThread (50ms interval) merges data and runs BasicComputer
4. CalculationThread (max 2x/sec) reads from DeviceBlackboard, runs GlideComputer
5. UI thread calls `XCSoarInterface::ReceiveGPS()` / `ReceiveCalculated()`
6. Data copied to InterfaceBlackboard, BlackboardListeners notified
7. Draw thread reads from MapWindowBlackboard

**Settings Flow:**
- UI modifies settings via `ActionInterface::*()` functions
- Settings propagate to DeviceBlackboard and then to devices
- Use `to_devices=true` parameter to send to hardware devices
- Settings are also saved to profile via `Profile::Set()` when appropriate

**Thread Flow:**
```
Device Threads → MergeThread → CalculationThread → UI Thread → Draw Thread
```

### Backend→UI Event Queue

**Pattern**: Backend code should NOT directly access UI components. Instead, use the event queue pattern for Backend→UI communication.

**Mechanism**: `InputEvents::processGlideComputer()`
- Backend code (e.g., `GlideComputer`, `ConditionMonitor`) calls `InputEvents::processGlideComputer(gce_id)` to queue events
- Events are queued and processed later by `InputEvents::DoQueuedEvents()` in the UI thread
- This is an **asynchronous event queue pattern** that maintains proper layer separation
- Events are defined in `Input/InputQueue.hpp` (e.g., `GCE_TASK_START`, `GCE_AIRSPACE_ENTER`)

**Example**:
```cpp
// In Backend code (e.g., GlideComputer, ConditionMonitor)
void TaskFinish() noexcept {
  InputEvents::processGlideComputer(GCE_TASK_FINISH);
  // Event is queued, will be processed in UI thread
}

// UI thread processes events via InputEvents::DoQueuedEvents()
// which calls processGlideComputer_real() to handle the event
```

**When to use**:
- Backend needs to notify UI of state changes (task start/finish, airspace warnings, etc.)
- Backend should NOT directly show dialogs or access UI components
- This pattern maintains proper layer separation while allowing Backend→UI communication

### Thread-Specific Code Patterns

**Device Driver Thread:**
```cpp
// In device driver's data handler (parsing incoming NMEA)
auto basic = blackboard.LockGetDeviceDataUpdateClock(index);
// Parse NMEA and update basic
// Update basic with parsed data (e.g., basic.location = ...)
blackboard.LockSetDeviceDataScheduleMerge(index, basic);
```

**Device Driver Callbacks:**
```cpp
// OnSensorUpdate: Called from MergeThread (with DeviceBlackboard mutex locked)
// Use for drivers that need to forward sensor data quickly (e.g., analog vario needle)
void OnSensorUpdate(const MoreData &basic) override {
  // Must not block, mutex is already locked
  // Forward sensor data to device quickly
}

// OnCalculatedUpdate: Called from UI thread (main thread) after CalculationThread run
// Use for drivers that need calculated data (task info, glide polar, etc.) to send to device
void OnCalculatedUpdate(const MoreData &basic,
                        const DerivedInfo &calculated) override {
  // Send calculated data to device (e.g., task information, glide polar)
  // Examples: VegaDevice, LXEosDevice, OpenVarioDevice
}
```

**UI Thread (InfoBox, Dialog, Widget):**
```cpp
// Read data (always use CommonInterface, never DeviceBlackboard)
const MoreData &basic = CommonInterface::Basic();
const DerivedInfo &calculated = CommonInterface::Calculated();

// Modify settings
ActionInterface::SetMacCready(mc, to_devices);

// Listen for changes
class MyWidget : public BlackboardListener {
  void OnGPSUpdate() override { /* refresh display */ }
  void OnCalculatedUpdate() override { /* update calculations */ }
};
// Register: blackboard.AddListener(*this);
// Unregister: blackboard.RemoveListener(*this);
```

**CalculationThread:**
```cpp
// Read from DeviceBlackboard (with lock)
const std::lock_guard lock{device_blackboard.mutex};
const MoreData &basic = device_blackboard.Basic();
// Perform calculations, write to GlideComputerBlackboard
```

**Map Rendering Thread:**
```cpp
// Read from MapWindowBlackboard (no lock needed, local copy)
const MoreData &basic = map_blackboard.Basic();
const DerivedInfo &calculated = map_blackboard.Calculated();
// Render map using this data
```

### Component Access Patterns

**Accessing Backend Components:**
```cpp
// Use global pointer (defined in Components.hpp)
if (backend_components != nullptr) {
  auto &device_blackboard = *backend_components->device_blackboard;
  // Access with lock
  const std::lock_guard lock{device_blackboard.mutex};
  // ...
}
```

**Accessing Data Components:**
```cpp
if (data_components != nullptr) {
  auto *waypoints = data_components->waypoints.get();
  auto *airspaces = data_components->airspaces.get();
  // ...
}
```

**Always check for nullptr** - components may not be initialized in all contexts (e.g., during startup/shutdown, in unit tests)

### Common Architectural Pitfalls

**DO NOT:**
- Access `InterfaceBlackboard` or `CommonInterface::*()` from non-UI threads
- Access `DeviceBlackboard` directly from UI thread (use `CommonInterface` instead)
- Add UI dependencies to Engine layer code
- Add Backend dependencies to Engine layer code
- Access components without checking for nullptr
- Forget to lock DeviceBlackboard when reading from device/calculation threads
- Use `DeviceBlackboard` in MapWindow rendering (use `MapWindowBlackboard`)
- Call `CommonInterface::*()` from device drivers or calculation threads
- Include UI headers (`Dialogs/`, `Form/`, `Widget/`) in device drivers or Backend code
- Call `ActionInterface` from device drivers or calculation threads
- Include `Engine/`, `Computer/`, `Device/`, or `Blackboard/` headers in Foundation or Platform layers
- Directly show dialogs or message boxes from Backend code (use event queue instead)

**DO:**
- Use `CommonInterface::*()` in UI code
- Use `ActionInterface::*()` for UI actions
- Lock DeviceBlackboard when accessing from device/calculation threads
- Use appropriate blackboard for each thread
- Register/unregister BlackboardListeners properly
- Check component pointers for nullptr
- Use `InMainThread()`, `InDrawThread()` assertions to verify thread context

### Adding a New Device Driver

1. Create driver class in `Device/Driver/YourDevice/`
2. Implement `Device` interface methods
3. Parse incoming data into `NMEAInfo` structure
4. Write to DeviceBlackboard:
   ```cpp
   auto basic = blackboard.LockGetDeviceDataUpdateClock(index);
   // Update basic with parsed data
   basic.location = parsed_location;
   basic.gps.fix_quality = FixQuality::GPS;
   // ... update other fields
   blackboard.LockSetDeviceDataScheduleMerge(index, basic);
   ```
5. Handle outgoing commands via `WriteNMEA()` or binary protocol
6. Implement callbacks if needed:
   - `OnSensorUpdate()`: For drivers that forward sensor data quickly (called from MergeThread)
   - `OnCalculatedUpdate()`: For drivers that send calculated data to device (called from UI thread)
7. Register driver in `Device/Driver/Register.cpp`
8. Add device configuration widget in `Dialogs/Device/YourDevice/` if needed

### Source Organization
- Code in `src/` directory with specific subdirectories (util/, Math/, Geo/, etc.)

### Threading
- UI thread: main thread, no other thread may manipulate windows
- Access sensor data from `CommonInterface::Basic()` in UI thread only
- Other threads must not use `Interface.hpp` library
- Use appropriate blackboards for different threads:
  - UI thread: `InterfaceBlackboard` via `CommonInterface::Basic()`
  - MapWindow (DrawThread): `MapWindowBlackboard`
  - Device drivers: write to `DeviceBlackboard::per_device_data[i]`, can implement `OnSensorUpdate()` (called from MergeThread) or `OnCalculatedUpdate()` (called from UI thread)
  - CalculationThread: lock `DeviceBlackboard` or use `GlideComputerBlackboard`

### Adding JNI Methods (Android)

Adding a new method callable between Java and C++ requires updating three files:

1. **Java class** (e.g., `android/src/NativeView.java`): declare the method
   ```java
   private void startMyService() { /* Java implementation */ }
   // or for native→Java:
   static native void someNativeMethod();
   ```
2. **C++ header** (e.g., `src/Android/NativeView.hpp`): add `static jmethodID` and wrapper
   ```cpp
   static jmethodID startMyService_method;
   void StartMyService(JNIEnv *env) const noexcept {
     env->CallVoidMethod(obj, startMyService_method);
   }
   ```
3. **C++ implementation** (e.g., `src/Android/NativeView.cpp`): register the method ID in `Initialise()`
   ```cpp
   startMyService_method = env->GetMethodID(cls, "startMyService", "()V");
   ```

- JNI function names follow: `Java_org_xcsoar_<Class>_<methodName>`
- All `jmethodID` values are static members cached during `Initialise()`, called from `InitNative()` in `Main.cpp`
- JNI signature strings: `()V` = void(), `(Ljava/lang/String;)V` = void(String), `(I)Z` = boolean(int)

### Cross-Platform Link/URI Handling

- Use `OpenLink()` from `system/OpenLink.hpp` for opening external URIs on all platforms
- Supported URI schemes are registered in `src/util/UriSchemes.hpp` in the `kUriSchemes[]` array
- When adding a new URI scheme, add it to `kUriSchemes[]` sorted longest-first (for overlapping prefix handling)
- Each scheme has: `{prefix, length, is_external}` where `is_external=true` means opened via `OpenLink()`
- Internal schemes (`xcsoar://`) use `is_external=false` and are handled by `InternalLink` dispatching
- Prefer standard URI schemes (`geo:`, `tel:`, `mailto:`, `https:`) over platform-specific APIs

## Privacy

### Network Activity and Tracking
- XCSoar operates offline by default; no network activity unless explicitly enabled by the user
- Network features (e.g., tracking services, weather downloads) must be opt-in and clearly documented
- No automatic tracking, telemetry, or analytics
- All network features should be clearly visible in settings and require user consent
- When implementing network features, respect user privacy settings and provide clear opt-out mechanisms

### Data Logging
- Avoid logging identifying or sensitive information:
  - Usernames, passwords, or authentication tokens
  - Device serial numbers or unique identifiers
  - Personal information that could identify users
- Log files (IGC, NMEA) contain flight data only; no personal identifiers should be embedded
- Debug logs should not contain sensitive data; sanitize or exclude passwords, tokens, and personal information
- When logging is necessary for debugging, use sanitized or anonymized data

### User Data Protection
- All user data is stored locally on the device
- No automatic transmission of user data to external servers
- User must explicitly choose to share data (e.g., upload IGC files, enable tracking)
- Respect user privacy preferences and settings

## GUI Guidelines

### Rendering Backends — Always Consider All Three

XCSoar has three canvas backends in `src/ui/canvas/`. **Every renderer implementation must work on all three:**

| Backend | Define | Platform | Capabilities |
|---------|--------|----------|-------------|
| **OpenGL** | `ENABLE_OPENGL` | Linux/Android/macOS | Full color, alpha blending, gradients, hardware-accelerated |
| **Memory canvas** | `USE_MEMORY_CANVAS` | Kobo e-ink, headless (`VFB=y`) | Software rendering, greyscale on e-ink, no GPU |
| **GDI** | `USE_GDI` | Windows | Win32 GDI API, full color but no alpha on all surfaces |

When writing or modifying renderer code (`src/Renderer/`, `src/Look/`, `MapWindow/`):
- **E-ink (memory canvas)**: No color, no gradients, no alpha blending. Use `IsDithered()` and `HasColors()` from `Asset.hpp`. Fall back to `COLOR_WHITE`/`COLOR_BLACK` with clear contrast.
- **OpenGL**: Can use `AlphaBlendEnable`/`Disable`, textures, and smooth anti-aliased rendering.
- **GDI**: Has color but limited alpha support. `Canvas::StretchMono()` and some blending operations differ.
- Use `#ifdef ENABLE_OPENGL` / `#ifdef USE_MEMORY_CANVAS` / `#ifdef USE_GDI` when backend-specific code is unavoidable.
- **Test with**: `TARGET=UNIX` (OpenGL default), `TARGET=UNIX OPENGL=n` (memory canvas), `TARGET=WIN64` (GDI).

### UI Scaling and DPI Support
- UI must scale from low-DPI devices (e.g., CGA resolution ~96 DPI) to very high-DPI devices (e.g., modern phones with 400+ DPI)
- Use `Layout::Scale()` for general UI element scaling (based on 240x320 base resolution)
- Use `Layout::PtScale()` for physical dimensions in points (1/72th inch)
- Use `Layout::VptScale()` for virtual points (accounts for viewing distance on small screens)
- Use `Layout::FontScale()` for font sizes (accounts for DPI, screen size, and user preference)
- Use `Layout::ScalePenWidth()` or `Layout::ScaleFinePenWidth()` for line widths
- Never use hardcoded pixel values; always use scaling functions from `Layout` namespace
- Base resolution: 240 pixels (320 for square displays) on the shortest dimension
- Small screens (< 5 inch) automatically get adjusted scaling for viewing distance
- Touch screens get larger hit areas and control heights
- Test UI changes on both low-DPI and high-DPI devices when possible

### Display and DPI — Consider All Targets

DPI detection, screen size queries, and display setup differ across targets. When implementing display-related features (DPI scaling, screen rotation, fullscreen, window management), ensure they work on all platforms:

| Target | Display | DPI detection | Notes |
|--------|---------|---------------|-------|
| **Android** | Native `SurfaceView` | System-provided density (`DisplayMetrics`) | Variable DPI (120–640), runtime rotation |
| **Linux/Wayland** | `wl_surface` | Compositor scale factor (`wl_output`) | HiDPI via integer/fractional scaling |
| **Linux/X11** | `XWindow` | `Xft.dpi` resource or fallback | May be inaccurate; `xrandr` for physical size |
| **Kobo** | Framebuffer (`/dev/fb0`) | Hardcoded per model | Fixed resolution, no rotation, no DPI query API |
| **Windows** | `HWND` (GDI) | `GetDpiForWindow()` / `GetDeviceCaps()` | Per-monitor DPI on Win10+ |
| **macOS/iOS** | Native view | `backingScaleFactor` / `UIScreen.scale` | Retina 2x/3x scaling |
| **SDL** | `SDL_Window` | `SDL_GetDisplayDPI()` | Cross-platform fallback, may be inaccurate |

Key rules:
- **Never assume a specific DPI or resolution** — always use `Layout::` scaling functions
- Platform-specific display code goes in `src/ui/window/<platform>/` and `src/ui/display/`
- Use `IsEmbedded()`, `IsKobo()`, `IsAndroid()` from `Asset.hpp` for target-specific branches
- **Kobo has no runtime DPI query** — screen parameters are hardcoded in device-specific setup
- **Android provides reliable DPI** but beware of foldables and external displays changing at runtime
- When adding a new display feature, check that it compiles with at least: `TARGET=UNIX`, `TARGET=ANDROID`, `TARGET=KOBO`, `TARGET=WIN64`

### UI Operability
- UI must be operable via multiple input methods: touch, keyboard, and gestures
- All user actions should be accessible through different input modalities
- Expose functionality that makes sense via `ActionInterface` namespace (e.g., `ActionInterface::SetMacCready()`, `ActionInterface::SetBallast()`)
- `ActionInterface` provides a clean API for UI actions that can be triggered by various input methods (touch, keyboard shortcuts, gestures, InputEvents)
- This allows the same functionality to be accessible regardless of input method
- Consider exposing commonly used actions through `ActionInterface` for consistency and accessibility
- **Navigation depth**: All actions used in-flight should be maximum 3 steps away from the main operation mode
- This ensures critical functions remain quickly accessible during flight operations
- Prioritize frequently used in-flight actions to be accessible with fewer steps
- **State change notifications**: Announce internal state changes to the user
- Use appropriate notification mechanisms (e.g., `StatusMessage`, `PopupMessage`, `OperationEnvironment::SetText()`) to inform users of important state changes
- Examples: GPS connection status, device connection/disconnection, task state changes, airspace warnings, system errors
- Ensure users are aware of changes that affect system behavior or require their attention

### Letter Cases
- Captions: Capitalization (e.g., "Pan On", "The Display Of...")
- Abbreviations: Upper case (e.g., "MC", "ETA", "V") or CamelCase (e.g., "GoTo", "InfoBox")
- Plain text: Write like prose
- Labels: Generally like prose, with exceptions where meaningful

### Colors
- Red: warning
- Orange: caution
- Green: positive safety indicator
- Blue: neutral safety indicator
- Grey: buttons
- Yellow: clicked items
- Light blue: key focused item
- Medium blue: dialogue title bar

### Safety
- Avoid elements that encourage continuous screen staring
- Avoid controls with significant risk if misconfigured
- Check for color blindness compatibility
- Follow aviation conventions (ICAO standards, IGC standards, NASA color usage, FAA guidelines)

## Look System

### Look Class Structure
- Look classes are `struct` types (not `class`), named with `*Look` suffix (e.g., `ButtonLook`, `DialogLook`, `MapLook`)
- The main `Look` struct in `src/Look/Look.hpp` aggregates all individual Look structs as members
- Each Look struct contains visual elements: `Pen`, `Brush`, `Color`, `Icon`, `Bitmap`, `Font` pointers, etc.
- Look structs are organized by UI component (e.g., `MapLook`, `InfoBoxLook`, `TaskLook`)

### Look Initialization
- Use `Initialise()` method (British spelling) for initial setup
- Use `Reinitialise()` or `ReinitialiseLayout()` for updates when settings change
- `Initialise()` methods typically take:
  - Settings structs (e.g., `UISettings`, `MapSettings`, `AirspaceRendererSettings`)
  - Font references (e.g., `const Font &font`, `const Font &bold_font`)
  - Layout parameters (e.g., `unsigned infobox_width`)
  - Dark mode flag (`bool dark_mode`)
- The main `Look::InitialiseConfigured()` method initializes all Look structs based on user settings
- Platform-aware initialization: use `IsDithered()`, `HasColors()`, etc. from `Asset.hpp` for conditional styling

### Look Naming and Organization
- Each Look struct should have its own `.hpp` and `.cpp` files in `src/Look/`
- Look structs should be included in the main `Look.hpp` file
- Member variables in Look structs use descriptive names (e.g., `standard`, `selected`, `focused` for button states)
- Use nested structs for related groups (e.g., `StateLook` within `ButtonLook`)

### Colors and Styling
- **All custom color literals must be defined as named constants in `src/Look/Colors.hpp`**; never use raw `Color(0x.., 0x.., 0x..)` hex literals inline in Look or rendering code
- `Colors.hpp` contains:
  - Brand colors: `COLOR_XCSOAR`, `COLOR_XCSOAR_LIGHT`, `COLOR_XCSOAR_DARK` (with `XCSOAR_TESTING` variants)
  - Dark theme palette: `COLOR_DARK_THEME_BACKGROUND`, `COLOR_DARK_THEME_CAPTION`, `COLOR_DARK_THEME_BUTTON`, `COLOR_DARK_THEME_GRADIENT_TOP`, `COLOR_DARK_THEME_LIST`, etc.
  - Light theme colors: `COLOR_DIALOG_BACKGROUND`, `COLOR_DIALOG_GRADIENT_TOP`
  - Admonition colors: `COLOR_ADMONITION_IMPORTANT`, `COLOR_ADMONITION_TIP`, etc.
- Standard colors from `ui/canvas/Color.hpp` (`COLOR_WHITE`, `COLOR_BLACK`, `COLOR_RED`, `COLOR_GREEN`, `COLOR_GRAY`, etc.) can be used directly
- Use `DarkColor()` and `LightColor()` helpers for derived shades rather than defining separate constants
- Follow color conventions (red=warning, orange=caution, green=safety, blue=neutral)
- Support dark mode when applicable (pass `dark_mode` parameter to `Initialise()`)
- **E-paper / monochrome display support:**
  - All UI code must remain usable on black-and-white e-paper displays (Kobo e-readers)
  - Use `IsDithered()` from `Asset.hpp` to detect e-paper displays and provide monochrome fallbacks
  - Use `HasColors()` to check if the display supports color; fall back to black/white or greyscale when false
  - Gradients, colored backgrounds, and alpha blending are not available on e-paper; use `COLOR_WHITE`/`COLOR_BLACK` instead
  - Example pattern in Look code:
    ```cpp
    if (IsDithered())
      SetBackgroundColor(COLOR_WHITE);
    else
      SetBackgroundColor(COLOR_DIALOG_BACKGROUND);
    ```
  - Buttons on e-paper use `COLOR_WHITE`/`COLOR_BLACK` with visible borders instead of colored backgrounds
  - Ensure sufficient contrast: text must be clearly readable in pure black on white (no light greys or subtle tints)
  - Test visibility of all new UI elements on monochrome displays when possible

## Translation and Internationalization Workflow

### Working with .po Files
- Translation files are located in `po/` directory (33 language files + `xcsoar.pot` template)
- Use `make update-po` to synchronize all `.po` files with source code changes
- **CRITICAL**: Never add custom comments (e.g., `# FIXME:`, `# TODO:`) between `#, fuzzy` and `msgid`, or between `msgid` and `msgstr`
- Valid comment placement: Before `#, fuzzy` or at the start of an entry block
- Comments violating `.po` syntax will cause `msgmerge` to fail during `make update-po`

### Translation Commit Organization
- Translation updates should be committed as a single, comprehensive commit
- Translation commits should generally be at the end of a feature branch
- Commit message format: `po: <brief summary of what was translated/fixed>`
- Include detailed description of what was fixed across which languages
- Use `make update-po` before committing translations to ensure line numbers are current
- Example commit structure:
  ```
  po: Update translations and fix incorrect msgid associations
  
  - Fix empty c-format translations for "%s: %s" across 30 languages
  - Correct Hungarian translations for airspace and task messages
  - Fix Croatian typo: "Iskjučen" → "Isključen"
  - Translate new strings ("XCSoar data path", "Click to view...") into all 33 languages
  - Update line number references via make update-po
  ```

### Translation Best Practices
- When adding new translatable strings, translate them into all 33 languages if possible
- Check for empty `msgstr` values in c-format strings (these cause blank UI text)
- Verify translations are semantically correct, not just syntactically valid
- Be aware of common translation confusion patterns (e.g., "No alternates available" vs "Update available")
- Use native speaker review when possible for quality assurance
- Test UI with translations enabled to catch display issues

### Running make update-po
- Run `make update-po` after any source code changes that add/modify translatable strings
- This updates:
  - Line number references in all `.po` files
  - Adds new `msgid` entries from source code
  - Marks changed strings as `#, fuzzy`
  - Updates the `po/xcsoar.pot` template
- Always commit `po/xcsoar.pot` along with `.po` file changes
- Review the diff after `make update-po` to catch any unintended changes

### What make update-po Actually Does

Under the hood, `make update-po` runs these operations:
1. Extracts all `_()` and `N_()` strings from source code → `po/xcsoar.pot`
2. For each `.po` file, runs `msgmerge` to:
   - Update line number references where strings are used
   - Add new `msgid` entries from source
   - Mark modified strings as `#, fuzzy` (needs review)
   - Remove obsolete entries (moved to bottom with `#~`)
3. Preserves existing translations (`msgstr` values)

**Important:** This is why `.po` syntax must be perfect - `msgmerge` is a strict parser!

### Debugging make update-po Failures

If `make update-po` fails with syntax errors:
1. Error will show which `.po` file and line number
2. Common causes:
   - Custom comments between `msgid` and `msgstr`
   - Malformed multiline strings
   - Missing quotes or escaped characters
3. Fix the syntax error and re-run
4. Use `msgfmt --check po/xx.po` to validate individual files
5. If multiple files are affected, fix them all before re-running `make update-po`

## Git History Management

### Interactive Rebase Best Practices
- Use `git rebase -i` for cleaning up commit history before submitting PRs
- Common cleanup operations:
  - **Squash**: Combine related commits (e.g., "Add feature" + "Fix feature" → single commit)
  - **Fixup**: Silently merge fixes into parent commits (auto-discards commit message)
  - **Reword**: Fix commit messages to follow project format
  - **Drop**: Remove commits (e.g., duplicates, reverted changes)
- Set `GIT_SEQUENCE_EDITOR` to automate rebase todo lists for scripted rebases
- Use `GIT_EDITOR=true` or `GIT_EDITOR=cat` to skip interactive editor prompts when commit message is already prepared

### Handling Rebase Conflicts
- When rebasing causes conflicts:
  1. Use `git status` to identify conflicted files
  2. For simple cases, use `git checkout --ours` or `git checkout --theirs`
  3. For translation files (`.po`), usually accept `--theirs` (the final translation commit)
  4. Always use `git add <resolved-files>` before continuing
  5. Use `git rebase --continue` to proceed
- If rebase becomes too complex, use `git rebase --abort` and try a different approach
- Consider breaking complex rebases into phases (e.g., reword → squash → cleanup)

### Commit Cleanup Patterns
- **Identify fixup candidates**: Look for sequential commits that modify the same component
- **Check for duplicates**: Compare commit timestamps and diffs to find exact duplicates
- **Find merge conflict fixes**: Look for commits with "merge conflict" or "fix conflict" that should be squashed into parent
- **Verify commit message format**: Scan for commits missing component prefixes or using generic "Fix"/"Update" subjects
- Use `git log --format="%H %s" --reverse` for scripting commit analysis
- Use `git diff-tree` to compare commit contents when checking for duplicates

### Cleanup Workflow Example
```bash
# Phase 1: Reword commit messages only (safest, no structural changes)
# Phase 2: Squash related commits (e.g., 3 related fixes into 1)
# Phase 3: Drop duplicates and fixup merge conflicts
# Phase 4: Verify final history with git log --oneline
```

### Handling Translation Commit Conflicts
- Translation commits often conflict during rebases (33+ files modified)
- Strategy: Accept `--theirs` for all `.po` and `.pot` files (the final translation state)
- Use: `git checkout --theirs po/*.po po/xcsoar.pot && git add po/`
- This preserves the comprehensive translation commit at the end of the branch

## Building XCSoar

### Compilation Basics
- Always use parallel builds: `make -j$(nproc)` (or `-j16`, `-j8`, etc.)
- Always use ccache: `USE_CCACHE=y` — significantly speeds up rebuilds
- Always build with warnings as errors: `WERROR=y` (enabled by default when `DEBUG=y`)
- Specify the target platform with `TARGET=`: `UNIX`, `ANDROID`, `WIN64`, `PC`, `KOBO`, etc.

### Common Build Commands
```bash
# Standard UNIX build (fastest for local development)
make -j$(nproc) TARGET=UNIX USE_CCACHE=y

# Full build including optional outputs, tests, and tools
make -j$(nproc) TARGET=UNIX USE_CCACHE=y everything

# Android debug build
make -j$(nproc) TARGET=ANDROID USE_CCACHE=y DEBUG=y

# Cross-compile for Windows
make -j$(nproc) TARGET=WIN64 USE_CCACHE=y

# Build with explicit warnings-as-errors (default in DEBUG)
make -j$(nproc) TARGET=UNIX USE_CCACHE=y WERROR=y
```

### Build Targets
- **`all`** (default): builds the main XCSoar binary for the selected target
- **`everything`**: builds `all` plus optional outputs, debug tools, `build-check` (unit tests), and `build-harness` (test utilities)
- **`check`**: runs unit tests after building them
- **`V=1`** or **`V=2`**: verbose output to see actual compiler/linker commands

### Key Build Variables
- `TARGET=`: platform (`UNIX`, `ANDROID`, `WIN64`, `PC`, `KOBO`, etc.)
- `DEBUG=y|n`: debug build (default `y`); enables assertions, debug symbols, and `WERROR=y`
- `WERROR=y`: treat all warnings as errors (defaults to `$(DEBUG)`)
- `USE_CCACHE=y`: use ccache for faster recompilation
- `OPENGL=y|n`: enable/disable OpenGL rendering (UNIX only; use `OPENGL=n` for memory canvas)
- `VFB=y`: virtual framebuffer for headless builds (implies `OPENGL=n`)
- `SANITIZE=y|address,undefined`: enable sanitizers (see Sanitizer Testing section)

## Build System Debugging

### Makefile Issues
- Build system is in `build/` directory with modular `.mk` files
- Each `.mk` file handles a specific library, feature, or platform (e.g., `build/wayland.mk`, `build/alsa.mk`)
- Generated files are tracked via variables like `WAYLAND_GENERATED`, `SDL_GENERATED`
- When debugging "No rule to make target" errors:
  1. Check if the expected target file exists in the variable definition
  2. Verify filenames match between generation rules and target rules
  3. Look for typos in intermediate file names (e.g., `-code.c` vs `-public.c`)

### Common Build Issues
- **Missing dependencies**: Check `*_LDLIBS` variables for required libraries
- **Protocol generation**: Wayland/SDL code generation must match expected output filenames
- **Cross-compilation**: Different platforms have different `.mk` includes; check `build/detect.mk`
- Use `make V=1` for verbose output to see actual command lines
- Check `build/options.mk` for feature flags that might need to be enabled

### Android Resource Pipeline
- `build/android.mk` and `build/android_bundle.mk` must be kept in sync; changes to one must be mirrored in the other
- Generated RGBA PNGs (from SVG sources) go to `output/data/graphics2/` and need explicit copy rules to `$(DRAWABLE_DIR)` in both Android Makefiles
- Resource copy rules use numbered variables (`PNG1`..`PNG9` etc.) and must be listed in the `PNG_FILES` aggregate variable
- When adding a new bitmap resource variant (e.g., white title for dark mode), all resolution tiers that the code can select must be provided; if the code has `huge`/`big`/`standard` selection logic, the new variant needs matching sizes or the highest-resolution tier will fall back to a lower-resolution variant and appear blurry

### Platform-Specific Builds
- Each platform may have platform-specific files in subdirectories (e.g., `src/ui/window/wayland/`, `src/ui/window/gdi/`)
- Use `#ifdef USE_WAYLAND`, `#ifdef USE_X11`, `#ifdef ANDROID` for conditional compilation
- Test changes on multiple platforms when possible (at minimum: Linux, Windows, Android)
- Pay attention to duplicate symbol definitions across platform implementations

### Platform Code Organization Patterns

**Core principle: maximize shared code, isolate platform differences through components and overloads.** Most logic (layout, data processing, rendering algorithms) should be cross-platform. Only the thin platform-specific layer (window creation, DPI query, input handling) needs per-platform code.

**Directory Structure:**
- `src/ui/window/custom/` - Shared base implementations (fallback/common code)
- `src/ui/window/gdi/` - Windows GDI-specific implementations
- `src/ui/window/wayland/` - Wayland-specific implementations  
- `src/ui/window/x11/` - X11-specific implementations
- `src/ui/window/sdl/` - SDL-specific implementations
- Similar patterns exist in `src/ui/canvas/`, `src/ui/event/`, `src/ui/display/`, etc.

**Code Reuse Strategy:**
1. **Put shared logic in `custom/`** — this is the default implementation compiled for all platforms that don't have a specific override. Maximize what lives here.
2. **Platform directories only override what differs** — a platform file should only contain the platform-specific parts, calling back into shared code for everything else.
3. Build system conditionally compiles appropriate files based on `USE_*` defines — only one implementation of each `.cpp` is compiled per target.
4. **Prefer method overloads and virtual dispatch over `#ifdef`** — when a class needs platform-specific behavior, implement the method in the platform directory rather than scattering `#ifdef` blocks in shared code.
5. **Use `#ifdef` in shared code only for small, isolated differences** — e.g., a single extra call or a type alias. If the `#ifdef` block grows beyond a few lines, extract it into a platform-specific file.

**When adding a new feature:**
- Start by implementing it entirely in `custom/` (cross-platform)
- Only create platform-specific overrides when something genuinely can't be done portably
- If a platform has a better/native API for the same thing, override just that method in the platform directory — keep the algorithm and data flow in shared code
- Check if platform-specific directory exists (e.g., `wayland/`, `gdi/`) before creating `#ifdef` blocks

**Good vs bad isolation:**
```cpp
// BAD: scattering platform logic throughout shared code
void TopWindow::SetFullScreen(bool full) {
#ifdef USE_WAYLAND
  xdg_toplevel_set_fullscreen(toplevel, nullptr);
#elif defined(USE_X11)
  XChangeProperty(display, window, ...);
#elif defined(USE_GDI)
  SetWindowLong(hwnd, GWL_STYLE, ...);
#else
  // fallback?
#endif
}

// GOOD: each platform overrides the same method in its own file
// custom/TopWindow.cpp — shared base (may be empty or have a fallback)
// wayland/TopWindow.cpp — Wayland-specific SetFullScreen()
// x11/TopWindow.cpp — X11-specific SetFullScreen()
// gdi/TopWindow.cpp — GDI-specific SetFullScreen()
// All share the same class, same header, same interface
```

### Finding Platform-Specific Implementations

When debugging or extending platform code:
1. Use `find src/ -name "TopWindow.cpp"` to see all platform implementations
2. Check `build/*.mk` files for which files are compiled per platform
3. Look for `#ifdef USE_*` guards in `custom/` files for platform conditionals
4. Grep for platform-specific functions to find where they're implemented:
   ```bash
   rg "CreateNative" src/ui/window/
   ```
5. Build system variables (in `build/detect.mk`) determine which platform is active

**Common platform defines:**
- `USE_GDI` - Windows GDI
- `USE_WAYLAND` - Wayland compositor
- `USE_X11` - X11 windowing
- `USE_SDL` - SDL2 framework
- `ANDROID` - Android platform
- `KOBO` - Kobo e-reader
- `USE_POLL_EVENT` - Poll-based event system (X11, Wayland)
- `USE_FB` - Linux framebuffer

## Sanitizer Testing

### Build with Sanitizers
- `SANITIZE=y` enables AddressSanitizer; `SANITIZE=address,undefined` enables both ASan and UBSan
- Sanitizers are **runtime checks** — issues are reported when the instrumented code executes, not at compile time
- The CI runs `SANITIZE=y` with `VFB=y` for the UNIX target on every PR
- **Always clean** (`rm -rf output/UNIX/dbg/`) when changing `SANITIZE=` settings — sanitizer and non-sanitizer builds share the same output directory, and stale object files cause phantom linker errors (`undefined reference to __ubsan_handle_*`, `typeinfo` mismatches)

### How to Run Locally
```bash
# Full sanitizer check (matches CI)
make -j$(nproc) TARGET=UNIX VFB=y SANITIZE=y DEBUG_GLIBCXX=y everything check
```

### Known Sanitizer Findings
- Third-party code (zzip, shapelib) triggers misaligned-access warnings — benign on x86
- `FastMath.hpp` uses intentional signed overflow for fast integer square root
- Unit tests cover math/parser/logic but **do not exercise UI rendering paths** — rendering bugs are only caught by running the application manually

## GitHub PR Review Workflow

### Responding to PR Comments
- Use `gh pr view <number> --comments` to retrieve all review comments programmatically
- Address all comments systematically:
  1. Read all comments first
  2. Categorize: typos, bugs, design issues, questions
  3. Fix issues in separate commits or squash into existing commits
  4. Document fixes in commit messages
- Use `gh pr comment <number>` to respond to specific review threads

### Fixing PR Issues
- **Small fixes** (typos, simple bugs): Either amend into existing commit or create fixup commit
- **Larger issues**: Create properly formatted new commit, then consider squashing during final cleanup
- **Translation issues**: Fix all languages, not just the one mentioned in review
- Document what was changed in response to review (helps reviewers verify fixes)

### Pre-PR Checklist
- Run `make update-po` if any translatable strings were added/modified
- Check that all `.po` files have valid syntax (no custom comments in wrong places)
- Verify commit messages follow format: `<Component>: <Summary>`
- Squash fixup commits and reword generic "Fix" messages
- Ensure branch compiles on at least one platform
- Check for accidentally committed debug code or temporary files
- Verify all user-visible changes have corresponding NEWS.txt entries
- When a NEWS.txt entry relates to a GitHub issue, include the issue number at the end (e.g., `#2145`)
- When adding Android drawable resources, check both `build/android.mk` and `build/android_bundle.mk`

## Common Mistakes and How to Avoid Them

### Translation File Mistakes
- ❌ Adding custom comments between `msgid` and `msgstr`
- ✅ Place comments before `msgid` or at entry start
- ❌ Forgetting to run `make update-po` after source changes
- ✅ Always run `make update-po` before committing translations
- ❌ Translating only one language when fixing an issue
- ✅ Fix the issue across all affected languages

### Git Workflow Mistakes
- ❌ Creating many small fixup commits during development
- ✅ Squash related commits before PR submission
- ❌ Generic commit messages: "Fix bug", "Update code"
- ✅ Use component prefix: "Device/Flarm: Fix buffer overflow"
- ❌ Committing translation files in middle of feature branch
- ✅ Move translation commit to end of branch

### Build System Mistakes
- ❌ Hardcoding filenames without checking generation output
- ✅ Verify generated file names match target rules
- ❌ Adding libraries to wrong `*_LDLIBS` variable
- ✅ Add to correct feature's LDLIBS (e.g., `AUDIO_LDLIBS` for sound)
- ❌ Platform-specific code without proper `#ifdef` guards
- ✅ Use appropriate platform detection macros
- ❌ Adding resource copy rules to `build/android.mk` but not `build/android_bundle.mk`
- ✅ Always update both Android Makefiles in sync
- ❌ Adding only one resolution tier for a new bitmap variant (e.g., 320px white title)
- ✅ Provide all resolution tiers the code can select (e.g., 320px + 640px)

### Code Organization Mistakes
- ❌ Including platform-specific headers in cross-platform code
- ✅ Keep platform code in platform-specific directories
- ❌ Implementing platform features in `custom/` when platform-specific files exist
- ✅ Use existing platform directories (e.g., `wayland/TopWindow.cpp`)
- ❌ Duplicating code across platform implementations
- ✅ Extract common code to shared base classes or utilities
- ❌ Using Android-specific JNI calls (e.g., `ShareText()`) when cross-platform alternatives exist
- ✅ Use `OpenLink()` with standard URIs (`geo:`, `https:`, `tel:`, `mailto:`) for cross-platform functionality

### Sanitizer and Testing Mistakes
- ❌ Assuming `unsigned` subtraction is safe without checking operand order
- ✅ Guard `unsigned a - unsigned b` with `if (a <= b) return;` to prevent underflow
- ❌ Dividing by image dimensions without zero checks
- ✅ Add `if (dim == 0) dim = 1;` guards before any division by width/height
- ❌ Using 3-byte pixel readers for 4-byte RGBA image data
- ✅ Match pixel reader stride to actual image format (RGB=3 bytes, RGBA=4 bytes)
- ❌ Declaring variables uninitialized when stricter warnings are enabled
- ✅ Initialize all local variables, especially when used conditionally (e.g., `double av = 0;`)
- ❌ Ignoring sanitizer reports from third-party code
- ✅ Triage: suppress known benign issues (misaligned access in zzip/shapelib), fix actionable ones

### Android-Specific Mistakes
- ❌ Using `SharedPreferences.apply()` (async) before `System.exit()`
- ✅ Use `SharedPreferences.commit()` (synchronous) when process termination follows immediately
- ❌ Starting Android foreground services unconditionally (e.g., in simulator mode)
- ✅ Start services from native code only when needed (e.g., after fly/sim mode selection)
- ❌ Relying on `stopService()` before `System.exit()` to cleanly stop `START_STICKY` services
- ✅ Use a `SharedPreferences` flag to prevent `START_STICKY` restart after intentional exit
